<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-设计模式之命令模式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/24/设计模式之命令模式/" class="article-date">
  <time datetime="2016-05-23T16:38:10.000Z" itemprop="datePublished">2016-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/24/设计模式之命令模式/">设计模式之命令模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/24/设计模式之命令模式/" data-id="cjrja9bs7000bwy2hp2mkb0nh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-code-style" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/23/code-style/" class="article-date">
  <time datetime="2016-05-22T17:14:07.000Z" itemprop="datePublished">2016-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/23/code-style/">良好代码风格是一种艺术 -- Objective-C</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作者写这篇文章的目的不是提供死板的规定，仅仅是建议，提供给开发者之间降低阅读代码的障碍。优秀的代码应该具备：<strong>代码简洁简明</strong>，<strong>代码自我翻译</strong>等特点。我一直认为–<strong>良好代码规范优先于性能</strong>。</p>
<hr>
<h1 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h1><h2 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h2><p>对于<code>getter</code>,<code>setter</code>属性尽量使用点（<code>.</code>）语法(除了在<code>init</code>和<code>dealloc</code>方法中，应该直接使用<code>实例变量</code>，至于原因稍后解释)。</p>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">view.backgroundColor = [UIColor redColor];</span><br><span class="line">[UIApplication sharedApplication].delegate;</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[view setBackgroundColor:[UIColor redColor]];</span><br><span class="line">   UIApplication.sharedApplication.delegate;</span><br></pre></td></tr></table></figure>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>条件语句体应该总是被花括号<code>{}</code>包裹，包括仅仅只有一句代码，且都不能省略，<code>if</code>与左圆括弧<code>(</code>之间有一个<code>空格</code>，右圆括弧<code>）</code>与左花括号<code>{</code>之间有一个<code>空格</code>。多条件判断的时候，可以先判断否定的情况。</p>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!isVaild) &#123;</span><br><span class="line">	return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!isVaild) &#123;return NO;&#125;</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!isVaild) </span><br><span class="line">return NO;</span><br></pre></td></tr></table></figure>
<p>Or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!isVaild) return NO;</span><br></pre></td></tr></table></figure>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)isValidUser:(User *)user &#123;</span><br><span class="line">	if (!user.name) &#123;return NO;&#125;</span><br><span class="line">	if (!user.password) &#123;return NO;&#125;</span><br><span class="line">	if (!user.email) &#123;return NO;&#125;</span><br><span class="line"></span><br><span class="line">	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)isValidUser:(User *)user &#123;</span><br><span class="line">	BOOL isValidForName = user.name;</span><br><span class="line">	BOOL isValidForPassword = user.password;</span><br><span class="line">	BOOL isValidForEmail = user.email;</span><br><span class="line">	BOOL isInValid = !isValidForName || !isValidForPassword || !isValidForEmail;</span><br><span class="line">	if (isInValid) &#123;</span><br><span class="line">		return NO;</span><br><span class="line">	&#125;</span><br><span class="line">	//其他条件</span><br><span class="line">	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)isValidUser:(User *)user &#123;</span><br><span class="line">	BOOL isValid = NO;</span><br><span class="line">	if (user.name)</span><br><span class="line">	&#123;</span><br><span class="line">		if (user.password) </span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			if (usr.email) &#123;</span><br><span class="line">				isValid = YES;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retrun isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="尤达表达式"><a href="#尤达表达式" class="headerlink" title="尤达表达式"></a>尤达表达式</h2><p>最好不要使用<code>尤达表达式</code>。<code>尤达表达式</code>是指，<code>比较者</code>与<code>被比较者</code>之间的前后关系，<code>不要</code>用<code>比较者</code>与<code>被比较者</code>相比较 <code>而是</code> 应该用<code>被比较者</code>与<code>比较者</code>相比较。简单说，就是<code>用</code> <code>变量</code>与    <code>参照物</code>相比较，而<code>不</code>是<code>参照物</code>与<code>变量</code>相比较。</p>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">id value = ?;//？代表某一个对象</span><br><span class="line">if ([value isEqual:@12]) &#123;</span><br><span class="line">	//code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (@12 isEqual:value) &#123;</span><br><span class="line">	//code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>当三元运算符的第二个参数的返回值与检查对象一致时，这样使用：</p>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">result = obj?:[self callOtherMethod];</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">result = obj? obj : [self callOtherMethod];</span><br></pre></td></tr></table></figure>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p>对于字面值我们应该使用<code>NSString</code>,<code>NSDictionary</code>,<code>NSArray</code>，<code>NSNumber</code>的简写形式来创建对象。</p>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSArray *cities = @[@&quot;成都&quot;，@&quot;北京&quot;,@&quot;上海&quot;];</span><br><span class="line">NSDictionary *productPrice = @&#123;@&quot;iPhone5&quot;:@&quot;4300&quot;,@&quot;iPhone6&quot;:@&quot;4800&quot;&#125;;</span><br><span class="line">NSNumber *age = @23;</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSArray *cities = [NSArray arrayWithObjects:@&quot;成都&quot;,@&quot;北京&quot;,@&quot;上海&quot;,nil];</span><br><span class="line">NSDicitionary *productPrice = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;4300&quot;,@&quot;iPhone5&quot;,@&quot;4800&quot;,@&quot;iPhone&quot;];</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>对于方法应该遵循苹果的规范，(<code>-/+</code>)应该与左圆括弧<code>(</code>有一个<code>空格</code>。</p>
<p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)sendMessage;</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)sendMessage;</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person: NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Not Preferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Person: NSObject &#123;</span><br><span class="line"></span><br><span class="line">	NSString *name;//或NSString *_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init-和-dealloc"><a href="#init-和-dealloc" class="headerlink" title="init 和 dealloc"></a>init 和 dealloc</h2><p><code>dealloc</code>方法应该放在实现文件的顶部，直接放在<code>@sythesize</code> 和 <code>@dynamic</code>的后面，<code>init</code>方法应该放在<code>dealloc</code>方法的后面。注意<code>init</code>方法里面永远不应该调用<code>setter</code>、<code>getter</code>方法，你应该直接访问<code>实例变量</code>。至于什么原因？在于一个对象只有在<code>init</code>返回之后，才完成初始化状态，只有这样才能说明创建的对象已经处于稳定的状态。同样，在<code>dealloc</code>中，也不能这样做。简单的一句话总结：总是使用<code>self.propery</code>这种形式(出于对内存管理考虑)，<code>切记除了</code>在 <code>init</code>和<code>dealloc</code>方法中，应该直接访问<code>实例变量</code>。原因：</p>
<p>If you’re trying to be as defensive as possible, then you have to operate<br>under the assumption that someone may have subclassed the class and overridden your public methods. These overrides may be assuming that when the method is invoked, all of the properties and ivars and everything are in a consistent and fully-initialized state.</p>
<p>So, if your initializer or dealloc method causes one of these overridden methods to be executed, then the logic of the method may do something incorrect. The best case scenario is that it works as intended. The worst case scenario is that you do something like dereference a NULL pointer or index beyond the bounds of an array or cause some data to become corrupted, etc.`</p>
<p>While you’re inside an initializer or dealloc method, your object is in an inconsistent state. Thus, if you’re trying to be as defensive as possible, you should avoid invoking methods that might be making assumptions about the state of the object.</p>
<p>请参考</p>
<ul>
<li><p><a href="https://github.com/NYTimes/objective-c-style-guide/issues/6" title="Ivars should be directly accessed in init&#39;ers #6" target="_blank" rel="noopener">Ivars should be directly accessed in init’ers #6</a></p>
</li>
<li><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6" title="Don’t Use Accessor Methods in Initializer Methods and dealloc" target="_blank" rel="noopener">Don’t Use Accessor Methods in Initializer Methods and dealloc</a></p>
</li>
</ul>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implement</span><br><span class="line">@sythesize age;</span><br><span class="line">@dynamic name;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line">- (id)init &#123;</span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line">	self = [super init];</span><br><span class="line">	if (self) &#123;</span><br><span class="line">			_name = @&quot;jumei&quot;;</span><br><span class="line">		_age = @&quot;4&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (id)init &#123;</span><br><span class="line"> 	if (self = [super init]) &#123;</span><br><span class="line">		self.name = @&quot;jumei&quot;;</span><br><span class="line">		self.age = @&quot;4&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便提一句，不要在<code>init</code>方法中，初始化耗时的代码，<code>init</code>方法中应该尽可能快速完成初始化并返回。</p>
<h2 id="BOOL-和-nil"><a href="#BOOL-和-nil" class="headerlink" title="BOOL 和 nil"></a>BOOL 和 nil</h2><p><code>变量</code>一定不要直接与<code>YES</code>作比较，至于什么原因?请参考<a href="http://woodjobber.github.io/2016/05/22/Bool/" target="_blank" rel="noopener">BOOL，你真的了解吗？</a></p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (!obj) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (obj == nil) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!isValid) &#123;</span><br><span class="line">&#125;</span><br><span class="line">if (isvalid == NO) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (isValid == YES) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="instancetype-amp-id"><a href="#instancetype-amp-id" class="headerlink" title="instancetype &amp; id"></a>instancetype &amp; id</h2><p>在<code>方便构造器</code>中，一定要使用 <code>intancetype</code>，而且在<code>init</code>方法应该多使用<code>instancetype</code>。请参考<a href="http://tewha.net/2013/02/why-you-should-use-instancetype-instead-of-id/" title="为什么应该用intancetype替代id" target="_blank" rel="noopener">为什么应该用intancetype替代id</a></p>
<p>pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString)name &#123;</span><br><span class="line"> </span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return self; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">＋ (instancetype)initWithName:(NSString)name &#123;</span><br><span class="line"> </span><br><span class="line">	if (self = [super init]) &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return self; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Block的循环引用"><a href="#Block的循环引用" class="headerlink" title="Block的循环引用"></a><code>Block</code>的循环引用</h2><p>当使用<code>block</code>时，一定要注意避免引用循环。可以使用<code>@weakify</code>/<code>@strongify</code>。</p>
<p>对于只调用一个方法：</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">[self executeBlock:^(NSString *str) &#123;</span><br><span class="line"></span><br><span class="line">	[weakSelf performSomethingWithString:str];</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>NOt Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[self executeBlock:^(NSString *str) &#123;</span><br><span class="line"></span><br><span class="line">	[self performSomethingWithString:str];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>对于调用多个方法：</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">[self executeBlock:^(NSString *str) &#123;</span><br><span class="line">	__strong _typeof(weakSelf) strongSelf = weakSelf;</span><br><span class="line">	if (strongSelf) &#123;</span><br><span class="line">		[strongSelf performSomethingWithString:str];</span><br><span class="line">		[strongSelf performOtherSomethingWithString:str];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">[self executeBlock:^(NSString *str) &#123;</span><br><span class="line">	[weakSelf performSomethingWithString:str];</span><br><span class="line">	[weakSelf performOtherSomethingWithString:str];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h1><p>命名注意两点：<strong>可读性</strong>与<strong>命名冲突</strong>。</p>
<h2 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h2><p>以<code>大写字母</code>作为前缀，可以使用<code>公司缩写</code>或者<code>项目名称缩写</code>。例如以<code>WJUserEnity</code>。形式：<code>大写字母</code>+<code>类名`</code>;命名要清晰，能够描述该类的功能。</p>
<h2 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h2><p>常量命名应该以<code>驼峰命名</code>，并以相关的类名作为前缀。形式：<code>类名</code>+<code>属性</code>。</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static const CGFloat WJOrderListTableViewCellHeight = 44.0f;</span><br><span class="line"></span><br><span class="line">   NSString *const WJOrderTableViewCellIdentifier = @&quot;WJOrderTableViewCellIdentifier&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>变量命名遵守尽可能描述的清楚,但也不要画蛇添足。形式：修饰词+[类型]。</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSString *title;</span><br><span class="line">NSAttributedString *titleAttributedString;</span><br><span class="line">NSDate *lastModifiedDate;</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSString *titleString;</span><br><span class="line">NSAtttributedString *titleAttributedStr;</span><br><span class="line">NSDate *lastModified;</span><br></pre></td></tr></table></figure>
<h2 id="define命名"><a href="#define命名" class="headerlink" title="#define命名"></a>#define命名</h2><p>以<code>k</code>开头+<code>类名</code>+<code>属性</code>的形式。</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define kWJOrderListTableViewCellHeight = 22.0f;</span><br></pre></td></tr></table></figure>
<h2 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h2><p>枚举命名要加相关类名前缀并且枚举值要有枚举类型前缀，最好用<code>NS_ENUM</code></p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger,UIViewAnimationTransition) &#123;</span><br><span class="line">	UIViewAnimationTransitionNone,</span><br><span class="line">	UIViewAnimationTransitonFlipFromLeft,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h2><p>方法命名主体采用<code>驼峰命名</code>。方法名前不要有下划线(<code>_</code>)，我比较推荐的一种写法是如果是<code>私有方法</code>,用<code>字母</code>+<code>下划线</code>的形式；可以使用情态动词（<code>can</code>,<code>should</code>,<code>will</code>等）来阐明含义，不要使用<code>do</code>。</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)requestNetwork;</span><br><span class="line">- (void)shouldRequstNetwork;</span><br><span class="line">私有方法</span><br><span class="line">- (void)wj_requestNetwork;</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)doRequstNetork;</span><br><span class="line">- (void)_requstNetwork;</span><br></pre></td></tr></table></figure>
<h2 id="带多参数方法命名"><a href="#带多参数方法命名" class="headerlink" title="带多参数方法命名"></a>带多参数方法命名</h2><p>方法返回类型与（<code>-/+</code>）符合之间应该有一个<code>空格</code>。尽可能少用<code>&quot;and&quot;</code>这个词。遵循苹果风格,参数前应该有一个描述性<code>关键词</code>。</p>
<p>pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)setProductName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)message ToClient:(NSString *)client;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)setProductName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)sendMessage:(NSString *)message :(NSString *)client;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;</span><br></pre></td></tr></table></figure>
<h2 id="类目命名"><a href="#类目命名" class="headerlink" title="类目命名"></a>类目命名</h2><p><code>类目命名</code>必须描述该类目的功能，且<code>首字母</code>必须<code>大写</code>。</p>
<p>Pereferred:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (JMAudioPlaying)</span><br></pre></td></tr></table></figure></p>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (audioPlaying)</span><br></pre></td></tr></table></figure>
<h2 id="类目方法命名"><a href="#类目方法命名" class="headerlink" title="类目方法命名"></a>类目方法命名</h2><p><code>类目方法命名</code>的格式：<code>小写字母</code>开头+<code>下划线</code>+<code>功能描述</code>;</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)jm_itemAtIndex:(NSUInteger)index;</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)itemAtIndex:(NSUInteger)index;</span><br></pre></td></tr></table></figure>
<p>这种格式是苹果官方推荐的，请参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW4" title="Avoid Category Method Name Clashes" target="_blank" rel="noopener">Avoid Category Method Name Clashes</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">Introduction to Coding Guidelines for Cocoa</a></li>
<li><a href="http://cocoadevcentral.com/articles/000082.php" target="_blank" rel="noopener">CocoaDevCentral</a></li>
<li><a href="https://github.com/github/objective-c-style-guide" title="Github" target="_blank" rel="noopener">Github</a></li>
</ul>
<h2 id="协议命名"><a href="#协议命名" class="headerlink" title="协议命名"></a>协议命名</h2><p>协议命名格式：类名+功能描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@protocol JMPickerViewDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol JMMessageData &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="代理方法命名"><a href="#代理方法命名" class="headerlink" title="代理方法命名"></a>代理方法命名</h2><p>协议方法命名形式：某类某个对象做了什么。</p>
<p>Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@protocol JMPickerViewDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)pickerView:(JMPickerView *)pickerView didTapRightButton:(UIButton *)button;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>Not Pereferred:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@protocol JMPickerViewDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)didTapRightButton:(UIButton *)button;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微信公众号：<code>嘀咕嘀咕（iOSSharers）</code></p>
<p><strong>扫二维码关注</strong></p>
<p><img src="http://i.imgur.com/TUz7oc9.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/23/code-style/" data-id="cjrja9bse000cwy2h03pinzl0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Bool" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/22/Bool/" class="article-date">
  <time datetime="2016-05-22T13:26:48.000Z" itemprop="datePublished">2016-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/22/Bool/">BOOL，你真的了解吗？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>BOOL</code>对于我们来说，再熟悉不过了，但是，你真的会用<code>BOOL</code>吗？哈哈，没别的意思，只是想说明<code>BOOL</code>其实还有点坑。也许你拥有多年的开发经验，有可能在开发中会因<code>BOOL</code>导致错误。哈哈，有可能你现在在想，<code>BOOL</code> 不就是 真<code>(1)</code>与假<code>(0)</code>的区别嘛，会有什么坑呢？或者 你会想，我是不是在乱说呢？。不要着急，请听我细细说来。希望我下面的介绍会给你带来启示。</p>
<hr>
<h1 id="BOOL-amp-bool"><a href="#BOOL-amp-bool" class="headerlink" title="BOOL &amp; bool"></a>BOOL &amp; bool</h1><p>我们都知道 <code>BOOL</code> 被定义在    <code>Objective-C</code>中（<strong>注意，在<code>64-bit</code> 的<code>iOS</code>设备或者模拟器上已经把<code>BOOL</code>定义成了<code>bool</code>,因此以下我们考虑其他平台，包括运行实例</strong>）。<code>bool</code>这种类型的布尔，出现在古老的<code>C</code>语言中。但是<code>BOOL</code>实际上是一种对带符号类型（<code>signed char</code>）的类型定义,它拥有 <code>8 bits</code>的存储空间。通过<code>#define</code>指令把YES定义为<code>1</code>，<code>NO</code>定义为<code>0</code>。<code>Objective-C</code>并不会将<code>BOOL</code>作为仅能保存<code>YES</code>或<code>NO</code>值的真正布尔类型来处理。编译器仍将<code>BOOL</code>看作为<code>8 bits</code>二进制数。<code>YES</code>和<code>NO</code>值只是在习惯上的一种理解,同时也是为了与<code>C</code>语言中的<code>false</code>和<code>true</code>区别与一致。<br>在<code>Objective-C</code>中是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if (TARGET_OS_IPHONE &amp;&amp; __LP64__)  ||  TARGET_OS_WATCH</span><br><span class="line">#define OBJC_BOOL_IS_BOOL 1 </span><br><span class="line">typedef bool BOOL;// 在64-bite下的iPhone，被定义成 bool</span><br><span class="line">#else</span><br><span class="line">#define OBJC_BOOL_IS_CHAR 1 </span><br><span class="line">typedef signed char BOOL;//定义 成 char类型</span><br><span class="line">// BOOL is explicitly signed so @encode(BOOL) == &quot;c&quot; rather than &quot;C&quot;</span><br><span class="line">// even if -funsigned-char is used.</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#if __has_feature(objc_bool)</span><br><span class="line">#define YES __objc_yes</span><br><span class="line">#define NO  __objc_no</span><br><span class="line">#else</span><br><span class="line">#define YES ((BOOL)1)</span><br><span class="line">#define NO  ((BOOL)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>而<code>bool</code>就两个值<code>0</code>和<code>非0</code>，其实是一种(<code>int</code>)整型，即<code>0</code>代表<code>false</code>,<code>非0</code>代表为<code>true</code>.简单的描述下应该是这样定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#ifndef FALSE</span><br><span class="line">#define FALSE 0</span><br><span class="line">#endif</span><br><span class="line">#ifndef TRUE</span><br><span class="line">#define TRUE 1</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>具体定义请谷歌一下。也许有人说<code>bool</code>应该是<code>0</code>和<code>1</code>.请不用纠结这个问题，这个问题源于<code>c</code>语言的版本问题。在<code>C</code>语言标准（<code>C98</code>）并没有定义布尔类型，所以判断真假以<code>0</code>为假，<code>非0</code>为真，而在<code>C99</code>中，解决了布尔类型的问题。<code>_Bool</code>(<code>bool</code>)变量只能赋值为<code>0</code>或<code>1</code>.非<code>0</code>的值都被存储为<code>1</code>.即<code>true</code>代表<code>1</code>，<code>false</code>代表<code>0</code>。请参考<code>C99</code>头文件<code>&lt;stdbool.h&gt;</code>对<code>bool</code>的定义。<br>因此<code>Objective-C</code>中的<code>BOOL</code>与<code>C</code>语言中<code>bool</code>是不同的。最大的区别就是两种定义的类型完全不同，一种使<code>char</code>，一种是<code>int</code>。<br>比如说我可以这样对<code>BOOL</code>、<code>bool</code>赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL isValue1 = 8960;//256</span><br><span class="line">bool isValue2 = 8960;//256</span><br><span class="line">   </span><br><span class="line">printf(&quot;value1 = %d,value2 = %d\n&quot;,isValue1,isValue2);</span><br></pre></td></tr></table></figure>
<p>你认为会得到怎样的结果呢？<br>输出结果是：<code>value1 = 0，value2 = 1</code>；<br>为什么会这样呢？请继续往下看…</p>
<hr>
<h1 id="BOOL–不要与YES作比较"><a href="#BOOL–不要与YES作比较" class="headerlink" title="BOOL–不要与YES作比较"></a>BOOL–不要与YES作比较</h1><p><code>YES</code>是<code>Objective-C</code>的真值，与值<code>1</code>相等。<code>BOOL</code>能够拥有从<code>-128</code>到<code>127</code>（包括零）任意一个零值，因此它代表了<code>255</code>种不同的真值。按照惯例，那些函数或者方法总是返回<code>YES</code>或者<code>NO</code>。但是，你不能依赖于它返回的是真值（<code>255</code>种值的任意一个），就说明与<code>YES</code>（它的值为<code>1</code>）就相等。因此与<code>YES(1)</code>想比较是一种不好的想法。像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ([obj1 has:obj2] == YES) &#123;</span><br><span class="line"> //code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为没有编译器会执行一个变量或者一个值，总是保持<code>YES</code>或者<code>NO</code>。<br>也许，你还不是很明白，没关系，我再举一个例子说明，直接与<code>YES</code>比较是不合理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static BOOL compareDifferent(int value1,int value2) &#123;</span><br><span class="line">    return value1 - value2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (BOOL)compareDifferenValue:(int)v1 value2:(int)v2 &#123;</span><br><span class="line">   return v1 - v2 ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然而，你像这样使用方法或者函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">if (compareDifferent(25,24) == YES) &#123;</span><br><span class="line">     printf(&quot;不相等\n&quot;);</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">  printf(“相等\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (compareDifferent(24,25) == YES) &#123;</span><br><span class="line">     printf(&quot;不相等\n&quot;);</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">  printf(“相等\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (compareDifferent(15,45) == YES) &#123;</span><br><span class="line">     printf(&quot;不相等\n&quot;);</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">  printf(“相等\n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (compareDifferent(512,256) == YES) &#123;</span><br><span class="line">     printf(&quot;不相等\n&quot;);</span><br><span class="line">   &#125;else &#123;</span><br><span class="line">  printf(&quot;相等\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上实例，你觉得会得到什么结果呢？会输出 “不相等”吗？。哈哈…，不好意思，编译器会给你开一个玩笑！，最终输出的结果会是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">不相等</span><br><span class="line">相等</span><br><span class="line">相等</span><br><span class="line">相等</span><br></pre></td></tr></table></figure>
<p>实际上返回值应该是<code>1</code>，<code>-1</code>，<code>-30</code>,<code>0</code>。注意最后一个输出为什么是<code>0</code>。当然，与<code>NO</code>相比较，总是安全的，因为在<code>C</code>语言中只有<code>0</code>代表<code>false</code>，在<code>OC</code>也一样 <code>YES</code> 和 <code>NO</code>。</p>
<p>我们来分析下，<code>512</code>与<code>256</code>相比较为什么是<code>相等</code>，即返回值是<code>0</code>。有这样一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BOOL trueOrFalse = (BOOL)256;</span><br><span class="line">   printf(&quot;-&gt;%d\n&quot;,trueOrFalse);</span><br></pre></td></tr></table></figure>
<p>输出结果是<code>0</code>即<code>NO</code>。我们把<code>256</code>转化成二进制位<code>1 0000 0000</code>。根据<code>BOOL</code>，是一个占<code>8 bits</code>的<code>char</code>类型。因此编译器会剔除高位的数据，保留低<code>8</code>位的数据。在这个<code>1 0000 0000</code>中，保留<code>0000 0000</code>,再转化成<code>10</code>进制为<code>0</code>，<code>0</code>在<code>OC</code>中被定义为<code>NO</code>。而 <code>512 - 256</code> 等于 <code>256</code>。因此会输出<code>相等</code>。我们把上面的代码片段 修改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool trueOrFalse = (bool)256;</span><br><span class="line"></span><br><span class="line">   printf(&quot;-&gt;%d\n&quot;,trueOrFalse);</span><br></pre></td></tr></table></figure>
<p>输出结果是<code>1</code>即<code>YES</code>。因为 <code>bool</code> 就两个值<code>0</code>和<code>1</code>。<br>再举一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSString *name = @&quot;test&quot;;</span><br><span class="line">   </span><br><span class="line">   BOOL haveName() &#123;</span><br><span class="line">    return (BOOL)name;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这种 返回的 结果是不确定的，有可能是<code>YES</code>，也有可能是<code>NO</code>。假设<code>name</code>的指针是<code>0x010CA683</code>,将返回<code>YES</code>，如果<code>name</code>指针是<code>0x010BA600</code>，将返回<code>NO</code>。<br>原因也是<code>BOOL</code>类型只会保留<code>8 bits</code>    的数据。为真的时候保留<code>0x83</code>,为假的时候保留<code>0x00</code>。因此你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if (name) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">retrun NO;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">retrun name !=nil ? YES : NO;</span><br></pre></td></tr></table></figure>
<p>因此，不要这样写是非常有必要的，千万不要这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Never do this</span><br><span class="line">if (someValue == YES ) &#123;</span><br><span class="line"> //code</span><br><span class="line">&#125;else &#123;</span><br><span class="line"> //code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Never do this</span><br><span class="line">if (someValue == true ) &#123;</span><br><span class="line"> //code</span><br><span class="line">&#125;else &#123;</span><br><span class="line"> //code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//代码规范不推荐这样写</span><br><span class="line">if (someValue == NO) &#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//代码规范推荐这样写</span><br><span class="line">if (！someValue) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>!!注意：以上实例可以建立一个 MAC工程，运行，观测其输出结果。！！</code></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>非常感谢你能看完本文文章，所以在使用<code>YES</code>与其他相比较的时候特别的注意，这也是在代码规范中特别要避免的地方。如上面有什么错误，请联系我<a href="mailto:`woodjobber@outlook.com" target="_blank" rel="noopener">`woodjobber@outlook.com</a>`。非常感谢！！！</p>
<p>微信公众号：<code>嘀咕嘀咕（iOSSharers）</code></p>
<p><strong>扫二维码关注</strong></p>
<p><img src="http://i.imgur.com/TUz7oc9.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/22/Bool/" data-id="cjrja9brp0000wy2huwy6u34q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-strategy" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/23/strategy/" class="article-date">
  <time datetime="2016-03-23T15:33:35.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/strategy/">设计模式之策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="策略模式的定义"><a href="#策略模式的定义" class="headerlink" title="策略模式的定义"></a>策略模式的定义</h2><p>定义一些列算法，将每一个算法封装起来，并让它们可以相互替换，策略模式是让算法对于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为模式，对象行为模式就是把行为看作面向对象的，是一种面向对象的思想，简单的理解就是，对象本身与算法使独立的，对象本身可以根据具体情况使用不同的算法（策略，具体行为）。</p>
<h2 id="情景分析"><a href="#情景分析" class="headerlink" title="情景分析"></a>情景分析</h2><p>情景1：把N种算法植入到同一段代码中，然互使用if-else 或者switch-case条件语句来决定要使用哪种算法？这些算法可能是相似的类函数或方法，用以解决相关的问题。</p>
<p>情景2：旅行出行方式，非常经典情景，不同的人要从A点到B点旅行，可以选择乘坐火车，汽车，飞机，骑自行车等。代码的实现一般都是通过if-else或者switch-case条件语句来决定不同人选择何种出行方式。</p>
<p><img src="http://i.imgur.com/MWlgqur.png" alt=""></p>
<h2 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h2><p>思考：<br>1.如何消除根据不同的对象决定使用什么算法或者什么出行方式的 一大堆if-else或者switch-case的判断；<br>2.如何让算法和对象分开来，使得算法可以独立于使用它的客户而变化。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>把每个算法封装成一个对象，就能解决以上两个问题，而 根据策略模式的定义，所以使用策略模式设计，此问题就会得到解决。策略模式的作用就是把对象本身与算法分开来，其功能非常强大，因为策略模式的核心思想就是面向对象编程的多形性思想。</p>
<h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><p>这里的 “算法” 并不一定是指 真正意义的算法，换句话说，可以是真正意义的算法（冒泡排序，二分法，快速排序等），也可以是指不同的方式或者方法,行为，去实现相同的 目的或者产生同样的效应。”算法” 即 “策略”。</p>
<h2 id="策略模式的结构"><a href="#策略模式的结构" class="headerlink" title="策略模式的结构"></a>策略模式的结构</h2><p>环境类（Context）：用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。<br>抽象策略类（Strategy）:定义所有支持的算法（策略）的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法（策略）。<br>具体策略类（ConcreteStrategy）:以Strategy为接口具体实现某一算法（策略）。</p>
<p><img src="http://i.imgur.com/tAskDDF.jpg" alt=""></p>
<h2 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h2><p>优点：<br>1，策略模式提供了可以替换继承关系的方法<br>2，灵活选择不同的策略<br>3，消除了if-else或者switch-case判断<br>4，策略模式提供了管理相关算法簇的方法<br>缺点:<br>1，客户端需要具体知道有哪些具体策略<br>2，会产生很多策略类</p>
<h2 id="策略模式适用性"><a href="#策略模式适用性" class="headerlink" title="策略模式适用性"></a>策略模式适用性</h2><p>1，一个对象需要动态的选择几种算法的一种<br>2，不希望客户端知道复杂的，与算法相关数据结构，在具体策略类中封装算法和数据机构，提供保密性和安全性<br>3，一个类操作中使用多个条件语句来定义许多行为</p>
<h2 id="策略模式的实现"><a href="#策略模式的实现" class="headerlink" title="策略模式的实现"></a>策略模式的实现</h2><h4 id="两种方式实现–继承与协议"><a href="#两种方式实现–继承与协议" class="headerlink" title="两种方式实现–继承与协议"></a>两种方式实现–继承与协议</h4><p>在基类中，<code>Person .h</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;Transport.h&gt;</span><br><span class="line">@interface Person: NSObject</span><br><span class="line">- (void)travelWithTransport:(Transport *)transport;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在<code>Person.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)travelWithTransport:(Transport *)transport&#123;</span><br><span class="line">       [transport travel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在<code>Transport.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface Transport:NSObject</span><br><span class="line">- (void)travel; //子类去实现</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在<code>Transport.m</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@implementation Transport</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>//子类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface Plane:Transport</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Plane</span><br><span class="line">-(void)travel&#123;</span><br><span class="line"></span><br><span class="line">      NSLog(&quot;by plane...&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Car:Transport</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Car</span><br><span class="line">-(void)travel&#123;</span><br><span class="line"></span><br><span class="line">   NSLog(&quot;by car...&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;Car.h&gt;</span><br><span class="line">#import &lt;Plane.h&gt;</span><br><span class="line">#import &lt;Person .h&gt;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">-  (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">     Person *xiaoming = [[Person alloc]init];</span><br><span class="line">     [xiaoming travelWithTransport:[[Car alloc]init] ];</span><br><span class="line">     [xiaoming travelWithTransport:[Plane new]];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如有发现bugs，请联系<a href="mailto:`woodjobber@outlook.com" target="_blank" rel="noopener">`woodjobber@outlook.com</a>`</p>
<p>项目地址：<a href="https://github.com/woodjobber/Design-Pattern-" title="监听键盘的隐藏与显示的新思路" target="_blank" rel="noopener">https://github.com/woodjobber/Design-Pattern-</a></p>
<p>微信公众号：嘀咕嘀咕（iOSSharers）</p>
<p><strong>扫二维码关注</strong></p>
<p><img src="http://i.imgur.com/TUz7oc9.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/23/strategy/" data-id="cjrja9bs5000awy2h3wpwsh01" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-isa" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/23/isa/" class="article-date">
  <time datetime="2016-03-23T00:21:23.000Z" itemprop="datePublished">2016-03-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/23/isa/">Object-C的继承isa指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a><code>isa</code>指针</h1><p><code>isa</code>指针的作用就是追溯谁是谁的谁的关系，假设有一个人叫小明，小明是谁的儿子，是谁的孙子。<code>isa</code>指针就是建立一种继承关系。那么<code>isa</code>指针指向该实例对象的类对象。针对于一个对象本身来说，它并不知道如何去应答一个方法，它本身既不包含方法的实现，也不包含有方法的指针。而是间接的通过继承来的<code>isa</code>转到自己的类，才能知道某一个方法。<br>在<code>Object-C</code>中，任何类的定义都是对象，类与类的对象（实例）并没有本质的区别，也就是类也是一种对象，叫类对象，通过类实例化后的对象，也称为对象，就就是<code>Object-C</code>面向对象语言的精髓，所以，任何对象都有<code>isa</code>指针。<br>每一个<code>OC</code>对象都有一个隐藏的数据结构，在这个数据结构中的第一个成员变量，它就是<code>isa</code>指针。<br>在<code>objc.h</code>中能看到类定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#if !OBJC_TYPES_DEFINED</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">	 Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line">#endif</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>可以看出： Class是一个objc_class结构类型的指针，id 是一个objc_object结构体类型的指针。</p>
<p>在<code>NSObject.h</code>里面： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line"></span><br><span class="line">   Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再点开 <code>Class</code> 的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	struct objc_class &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">	#if !__OBJC2__</span><br><span class="line"></span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isa</code>:是一个<code>Class</code>类型的指针，每个实例对象都有一个<code>isa</code>指针，并且指向对象的类，而<code>Class</code>里也有个<code>isa</code>的指针，指向元类，什么是元类？就是类方法的类，保存了类方法的列表。当某一个类方法被调用时，先会查找本身类方法中的实现方法，如果没有，元类会向他父类查找该方法。元类也是对象，最终指向根元类，根元类<code>isa</code>指向本身。<br><code>super_class</code>:父类，如果该类已经是最顶层的根类，那么它为<code>NULL</code>。<br><img src="http://i.imgur.com/KrzmwVt.png" alt=""></p>
<p>类通过类的<code>isa</code>指针指向元类，根元类<code>isa</code>指针指向本身。</p>
<p>举例：<br>假设新建一个<code>Parent</code>,继承与<code>NSObject</code>,里面有成员方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-(void)run；</span><br><span class="line">+(void)sing;</span><br></pre></td></tr></table></figure></p>
<p>在新建一个类<code>Child</code>,继承于<code>Parent</code>,里面有成员方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-(void)playC;</span><br><span class="line">+(void)dump;</span><br></pre></td></tr></table></figure>
<p>实例化一个对象<code>Child *xiaoming = [[Child alloc]init];</code><br>注意：当我们调用<code>[xiaoming class]</code>的时候，<code>xiaoming</code>会通过它的<code>isa</code>指针去寻找<code>xiaoming</code> 的 <code>class</code>，即 <code>Child</code>。<br>当我们调用<code>[xiaoming superclass]</code>的时候，<code>xiaoming</code>通过<code>isa</code>找到<code>xiaoming</code>的<code>class</code>即<code>Child</code>类，在通过<code>super_class</code>，找到<code>Parent</code>类。</p>
<p>调用<code>[xiaoming playC]</code>，<code>xiaoming</code>通过<code>isa</code>找到<code>Child</code>类，在<code>class</code>的方法列表里面找到<code>playC</code>；</p>
<p>再试着调用<code>[xiaoming run]</code>，<code>xiaoming</code>通过<code>isa</code>找到<code>Child</code>类，发现该类里面并没有这个方法，通过该类里面的<code>super_class</code>找到<code>Parent</code>类，在里面的方法列表找到了<code>run</code>；</p>
<p>再是类方法<code>[Child dump]</code>，<code>Child</code>通过<code>isa</code>找到<code>Child</code>类，通过该类的<code>isa</code>找到<code>Child</code>的<code>metaclass</code>，在metaclass的方法列表里面找到了<code>+(void)dump</code>；</p>
<p>再试着调用<code>[Child sing]</code>，<code>Child</code>通过<code>isa</code>找到<code>Child</code>类，通过该类的<code>isa</code>找到<code>Child</code>的<code>metaclass</code>，发现metaclass里面并没有这个方法，通过<code>metaclass</code>里面的<code>super_class</code>找到<code>Parent</code>的<code>metaclass</code>，在里面的方法列表找到了<code>+(void)sing</code>；</p>
<p><code>objc_class</code>有两种类型：<br><code>class</code>与<code>metaclass</code>；<br><code>class</code>:实例对象的isa指向的结构体;<br><code>metaclass</code>：<code>class</code>的<code>isa</code>指向的一个结构体；</p>
<pre><code>**`isa` 指针的最大作用 即是 寻找 `谁是谁的谁` 关系。**
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微信公众号：<code>嘀咕嘀咕（iOSSharers）</code></p>
<p><strong>扫二维码关注</strong></p>
<p><img src="http://i.imgur.com/TUz7oc9.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/23/isa/" data-id="cjrja9bry0005wy2hyncxokei" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-keyboard" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/keyboard/" class="article-date">
  <time datetime="2016-03-21T13:55:35.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/keyboard/">另一种思路监听键盘的隐藏与显示</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="监听键盘的隐藏与显示"><a href="#监听键盘的隐藏与显示" class="headerlink" title="监听键盘的隐藏与显示"></a>监听键盘的隐藏与显示</h1><p>监听键盘的隐藏与显示，其实原始的比较简单，只需要观察四个通知名称：</p>
<pre><code>`UIKeyboardWillShowNotification` 
`UIKeyboardWillHideNotification`
`UIKeyboardDidShowNotification`
`UIKeyboardDidHideNotification`
</code></pre><p>实现方式是这样的 </p>
<pre><code>`[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];`

`[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector    (keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];`
`[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidShow:) name:UIKeyboardDidShowNotification object:nil];`

`[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector    (keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)keyboardWillHide:(NSNotification*)aNotification&#123;</span><br><span class="line"> //代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)keyboardWillShow:(NSNotification*)aNotification&#123;</span><br><span class="line">	//代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)keyboardDidHide:(NSNotification*)aNotification&#123;</span><br><span class="line"> //代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)keyboardDidShow:(NSNotification*)aNotification&#123;</span><br><span class="line">	//代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，在我的项目里面，如果使用以上方法去监听键盘的隐藏与显示，会编写比较多的代码以及代码逻辑判断很复杂，还有就是，在系统键盘与第三方键盘之间切换时，有时候不会走这个方法，因此，我就换了一种思路去解决这样的bugs，我仅仅是通过监听<code>UIKeyboardWillChangeFrameNotification</code>这个通知，然后通过键盘的<code>y</code>坐标与屏幕高度作比较，如果<code>y</code>值 大于或者等于屏幕高度则为键盘隐藏，相反，<code>y</code>值小于屏幕高度则为键盘显示。这样既可以解决第三方键盘 的高度变化的问题，又可以少写代码。<code>没有代码展示都是耍流氓！</code><br>代码如下：<br><code>.h</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef void(^GRUCAnimationsWithKeyboardBlock)(CGRect keyboardRect,CGFloat 	keyboardOffset,NSTimeInterval duration,BOOL isShowing);</span><br><span class="line">typedef void(^GRUCBeforeAnimationsWithKeyboardBlock)(CGRect keyboardRect,CGFloat 	keyboardOffset,NSTimeInterval duration,BOOL isShowing);</span><br><span class="line">typedef void(^GRUCCompletionKeyboardAnimationsBlock)(BOOL finished);</span><br><span class="line">typedef void(^GRUCCompletionBeforeUnsubscribeKeyboardBlcok)(void);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface GRUCChatPanelView (KeyboardAnimation)</span><br><span class="line">@property (nonatomic,assign) CGFloat yOffset; // keyboard offset if yOfset &lt; 0, the keyboard is Showing,otherwise, it is Hiddening.</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  To the notification center, subscribe to a change in the keyboard position of the observer.</span><br><span class="line">	 *  The name of the object observered is &apos;UIKeyboardWillChangeFrameNotification&apos;.</span><br><span class="line"> *  @param animations perform the  same as the keyboard animations.</span><br><span class="line">	 *  @param completion after the keyboard animations completion, Maybe you have other things to do.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">- (void)gruc_subscribeKeyboardWithAnimations:(GRUCAnimationsWithKeyboardBlock)animations completion:(GRUCCompletionKeyboardAnimationsBlock)completion;</span><br><span class="line">- (void)gruc_subscribeUIkeyboardNotification;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  To the notification center,subscribe to a change in the keyboard postion ofhte observer.</span><br><span class="line">	 *</span><br><span class="line"> *  @param beforeAnimations before performing the keyboard animations,Maybe you 	have other things to do.</span><br><span class="line">	 *  @param animations       perform the keyboard animations.</span><br><span class="line">  	 *  @param completion       the keyboard animaitons completion.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">- (void)gruc_subscribeKeyboardWithBeforeAnimations:(GRUCBeforeAnimationsWithKeyboardBlock)beforeAnimations</span><br><span class="line">                                       animations:(GRUCAnimationsWithKeyboardBlock)animations</span><br><span class="line">                                       completion:(GRUCCompletionKeyboardAnimationsBlock)completion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	*  Cancel subscriber for change the postion of the keyboard.</span><br><span class="line">	*/</span><br><span class="line">- (void)gruc_unsubscribeKeyboard;</span><br><span class="line">- (void)gruc_unsubscribeUIKeyboardNotification;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">	*  Cancel subcriber for change the postion of the keyboard. but before canceling subcriber,Maybe you have other things to do.</span><br><span class="line">*</span><br><span class="line">	*  @param completion completion context.</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">- (void)gruc_beforeUnsubscribeKeyboard:(GRUCCompletionBeforeUnsubscribeKeyboardBlcok)completion;</span><br></pre></td></tr></table></figure>
<p><code>.m</code>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	-(void)gruc_subscribeKeyboardWithAnimations:(GRUCAnimationsWithKeyboardBlock)animations completion:(GRUCCompletionKeyboardAnimationsBlock)completion&#123;</span><br><span class="line">    [self gruc_subscribeKeyboardWithBeforeAnimations:nil animations:animations completion:completion];</span><br><span class="line">	&#125;</span><br><span class="line"> 	-(void)gruc_subscribeKeyboardWithBeforeAnimations:(GRUCBeforeAnimationsWithKeyboardBlock)beforeAnimations animations:(GRUCAnimationsWithKeyboardBlock)animations completion:(GRUCCompletionKeyboardAnimationsBlock)completion&#123;</span><br><span class="line">    [self gruc_unsubscribeKeyboard];</span><br><span class="line">    objc_setAssociatedObject(self, GRUCBeforeAnimationsBlockAssociationKey, beforeAnimations, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, GRUCAnimationsBlockAssociationKey, animations, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, GRUCAnimationsCompletionBlockAssociationKey, completion, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    [self gruc_subscribeUIkeyboardNotification];</span><br><span class="line">	&#125;</span><br><span class="line"> 	-(void)gruc_subscribeUIkeyboardNotification&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(gruc_keyboardWillChangeFrame:) name:UIKeyboardWillChangeFrameNotification object:nil];</span><br><span class="line">	&#125;</span><br><span class="line">	-(void)gruc_unsubscribeKeyboard&#123;</span><br><span class="line">    [self gruc_beforeUnsubscribeKeyboard:nil];</span><br><span class="line">	&#125;</span><br><span class="line"> 	-(void)gruc_unsubscribeUIKeyboardNotification&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter]removeObserver:self name:UIKeyboardWillChangeFrameNotification object:nil];</span><br><span class="line">	&#125;</span><br><span class="line"> 	-(void)gruc_beforeUnsubscribeKeyboard:(GRUCCompletionBeforeUnsubscribeKeyboardBlcok)completion&#123;</span><br><span class="line">    if (completion) &#123;</span><br><span class="line">        completion();</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(self, GRUCBeforeAnimationsBlockAssociationKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, GRUCAnimationsBlockAssociationKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    objc_setAssociatedObject(self, GRUCAnimationsCompletionBlockAssociationKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    [self gruc_unsubscribeUIKeyboardNotification];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark -</span><br><span class="line">#pragma mark -- private methods</span><br><span class="line"></span><br><span class="line">-(void)gruc_keyboardWillChangeFrame:(NSNotification *)notification&#123;</span><br><span class="line">    </span><br><span class="line">    BOOL isShowing;</span><br><span class="line">    NSDictionary *info = [notification userInfo];</span><br><span class="line">    CGFloat duration = [[info objectForKey:UIKeyboardAnimationDurationUserInfoKey] floatValue];</span><br><span class="line">    CGRect beginKeyboardRect = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue];</span><br><span class="line">    CGRect endKeyboardRect = [[info objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];</span><br><span class="line">  </span><br><span class="line">    UIViewAnimationCurve curve = (UIViewAnimationCurve)[[notification.userInfo objectForKey:UIKeyboardAnimationCurveUserInfoKey] integerValue];</span><br><span class="line">    CGFloat offset = endKeyboardRect.origin.y - beginKeyboardRect.origin.y;</span><br><span class="line">    self.yOffset += offset;</span><br><span class="line">    </span><br><span class="line">    isShowing = endKeyboardRect.origin.y &gt;= kScreenHeight ?NO:YES;</span><br><span class="line">    </span><br><span class="line">    GRUCAnimationsWithKeyboardBlock animationsBlock = objc_getAssociatedObject(self, GRUCAnimationsBlockAssociationKey);</span><br><span class="line">    GRUCBeforeAnimationsWithKeyboardBlock beforeAnimationsBlock = objc_getAssociatedObject(self, GRUCBeforeAnimationsBlockAssociationKey);</span><br><span class="line">    GRUCCompletionKeyboardAnimationsBlock completionBlock = objc_getAssociatedObject(self, GRUCAnimationsCompletionBlockAssociationKey);</span><br><span class="line">    </span><br><span class="line">    if (beforeAnimationsBlock) &#123;</span><br><span class="line">        beforeAnimationsBlock(endKeyboardRect,offset,duration,isShowing);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [UIView animateWithDuration:duration delay:0 options:UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</span><br><span class="line">        [UIView setAnimationCurve:curve];</span><br><span class="line">        if (animationsBlock) &#123;</span><br><span class="line">            animationsBlock(endKeyboardRect,offset,duration,isShowing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; completion:completionBlock];</span><br><span class="line">    </span><br><span class="line">	&#125;</span><br><span class="line">	-(CGFloat)yOffset&#123;</span><br><span class="line">    return [objc_getAssociatedObject(self, externVarableKey) doubleValue];</span><br><span class="line">	&#125;</span><br><span class="line">	-(void)setYOffset:(CGFloat)yOffset&#123;</span><br><span class="line">    objc_setAssociatedObject(self, externVarableKey, @(yOffset), OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如有发现bugs，请联系<a href="mailto:`woodjobber@outlook.com" target="_blank" rel="noopener">`woodjobber@outlook.com</a>`</p>
<p>项目地址：<a href="https://github.com/woodjobber/GRUCChatPanelView" title="监听键盘的隐藏与显示的新思路" target="_blank" rel="noopener">https://github.com/woodjobber/GRUCChatPanelView</a></p>
<p>微信公众号：嘀咕嘀咕（iOSSharers）</p>
<p><strong>扫二维码关注</strong></p>
<p><img src="http://i.imgur.com/TUz7oc9.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/21/keyboard/" data-id="cjrja9bsf000dwy2hruw8kp62" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-architecture" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/21/architecture/" class="article-date">
  <time datetime="2016-03-21T12:57:46.000Z" itemprop="datePublished">2016-03-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/21/architecture/">移动应用App的分层架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在iOS上使用MVC会让人感觉不可思议？是否考虑转变成MVVM？也许你听说过VIPER，但是你不确定哪种架构才值得拥有？<br>继续阅读下面的文章，你将会找到以上涉及问题的答案，如果你不会随意抱怨在文章中的阐述的个人观点。<br>你将要构建你的知识关于在iOS环境中的架构模式。我们将简要的回顾一些流行的，并且比较它们在理论与实践中通过一些例子。如果你需要了解它们中任意一个的更多的细节，请按照链接方式打开。<br>掌握设计模式可能让人着迷，因此要深思：你可能在阅读这篇文章之前，问自己更多的问题，像下面这些：</p>
<ul>
<li>谁应该对自己发起发起网络请求：是一个模型还是控制器？</li>
<li>怎样把模型传递给一个新视图的视图模型？</li>
<li>谁创建一个新的VIPER模块：Router 还是 Presenter?</li>
</ul>
<p><img src="http://i.imgur.com/3iNtESG.png" alt=""></p>
<h1 id="为什么要重视选择架构？"><a href="#为什么要重视选择架构？" class="headerlink" title="为什么要重视选择架构？"></a>为什么要重视选择架构？</h1><p>因为如果你没有选择一个架构，有一天，调试一个拥有几十个不同的东西的大类，你将会发现你自己很难找到并且修复这些bugs在你的类中。显然，很难把这些类当做一个整体，这样，你将总是遗漏一些重要的细节。如果你已经处于这样的情景在你的应用程序中，它很有可能是这样的：</p>
<ul>
<li>这个类是 <code>UIViewController</code> 的子类。</li>
<li>你的数据直接存储在UIViewControllerView中</li>
<li>你的UIViews几乎什么也没有</li>
<li>这个模型是一个无效的数据结构</li>
<li>你的单元测试没有涉及到<br>这可能会发生，尽管这个事实是你按照苹果官方指导实现的MVC模式，因此，你不要灰心，这个与苹果的MVC有些错误。但是我们将稍后陈述。</li>
</ul>
<p>让我们定义一个好的架构特点：</p>
<ol>
<li>严格的实体角色责任均衡分配；</li>
<li>可测试性通常是架构的首要特点（不要担心：它很容易适应架构）；</li>
<li>使用方便以及维护成本极低。</li>
</ol>
<h1 id="为什么要分配？"><a href="#为什么要分配？" class="headerlink" title="为什么要分配？"></a>为什么要分配？</h1><p>当我们试图弄清楚事情如何工作的时候，我们的大脑会对我们的大脑有一个均衡的负荷。如果你想你发展的越来越好，你的大脑会适应复杂的理解，那么你就对了。但这种能力并没有线性扩展，很快到达瓶盖。因此，最简单的方法来击败复杂的是，在多个实体之间的责任遵循单一的责任原则。</p>
<h1 id="为什么要可测试性？"><a href="#为什么要可测试性？" class="headerlink" title="为什么要可测试性？"></a>为什么要可测试性？</h1><p>这通常不是一个问题对于那些友好的单元测试，但是在增加一些新的功能或者重构一个类后会失败。这意味着这些开发者在运行时就会发现问题，这可能会发生在一个应用程序在用户的设备，并且修复需要一个星期的时间才能到达用户。</p>
<h1 id="为什么要使用方便"><a href="#为什么要使用方便" class="headerlink" title="为什么要使用方便"></a>为什么要使用方便</h1><p>这并不要求一个答案，但是值得提醒的是最好的代码就是没有代码，因此拥有很少的代码，就会拥有很少的错误。这意味着，写更少的代码的想法，不应该被解释成仅仅是懒惰的开发者，你不应该支持一个更聪明的解决方案，去忽略你看到的它的维护成本。</p>
<h1 id="MV-X-环节"><a href="#MV-X-环节" class="headerlink" title="MV(X)环节"></a>MV(X)环节</h1><p>如今我们又很多的选择当我设计到架构模式的时候：</p>
<ul>
<li>MVC</li>
<li>MVP</li>
<li>MVVM</li>
<li>VIPER</li>
</ul>
<p>它们当中的前三个假定把应用程序的实体分成三类：</p>
<ul>
<li>Models -代表着数据区域或者数据访问层，那些持有数据，像Person或PersonDataProvider类</li>
<li>Views -代表呈现层（GUI）,对于iOS环境来说，以”UI”开头。</li>
<li>Controller/Presenter/ViewModel -模型和视图之间的粘合或介体，一般负责通过对用户的行为进行反应，并在模型中修改视图，然后从模型中更新视图</li>
</ul>
<p>分割实体让我们理解：</p>
<ul>
<li>理解它们更好</li>
<li>重用它们</li>
<li>单独测试它们<br>让我们先了解MV(X),最好回顾VIPER</li>
</ul>
<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h4 id="如何使用它"><a href="#如何使用它" class="headerlink" title="如何使用它"></a>如何使用它</h4><p>在讨论苹果的MVC版本之前，让我们认识下传统的MVC。</p>
<p><img src="http://i.imgur.com/Z4sqncN.png" alt=""></p>
<p>在这个例子中，View是无状态的，一旦Model被改变，它完全有控制器提供。想想下web网页完全的重载，一旦你按下链接，将会导航到其他地方。尽管实现传统的MVC在iOS应用中是可能的，但是这是毫无意义的，因为架构的问题–三个实体紧耦合的，没一个实体都知道其他两个，这个大大降低了它们中每一个可重用性–这就是不要使用在自己的应用程序中。对于这个原因，我们忽略写这个典型的MVC例子。、</p>
<p><strong>传统的MVC似乎不适用现代的iOS开发</strong></p>
<h1 id="Apple’s-MVC（期望的）"><a href="#Apple’s-MVC（期望的）" class="headerlink" title="Apple’s MVC（期望的）"></a>Apple’s MVC（期望的）</h1><p><img src="http://i.imgur.com/Kfalggs.png" alt=""><br>这个控制器是一个中介，在视图和模型之间，因此它们相互不了解，很少的可重用性是控制器，这通常是好的对于我们来说，由于我们需要有一个地方，存放哪些不适合放到模型的所有棘手的业务逻辑。<br>在理论上，它看起来很简单，但是你觉得有些问题，对不？你甚至听到其他人抱怨MVC是一个臃肿MVC。而且，视图控制器瘦身将成为一个重要的课题对于iOS开发者来说。为什么是这样的难道苹果仅仅是把传统的MVC改进了一点点吗？</p>
<h1 id="Apple’s-MVC（Reality）"><a href="#Apple’s-MVC（Reality）" class="headerlink" title="Apple’s MVC（Reality）"></a>Apple’s MVC（Reality）</h1><p>真正的Cocoa MVC<br><img src="http://i.imgur.com/CmdnExJ.png" alt=""><br>Cocoa MVC鼓励你去写Massive View Controllers.因为他们设计到视图的什么周期，这很难说他们是分开的。尽管你仍然有能力去减少一些业务逻辑和数据交换对于Model，但是你还没太多的选择，当涉及到对于视图而减少工作。在绝大多数时间，视图控制器的责任是发送行为给控制器。这个视图控制器最终成为一个代理并且是数据源以及通常负责发起和取消网络请求…<br>你有多少次看见你的代码像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var userCell = tableView.dequeueReusableCellWithIdentifier(&quot;identifier&quot;) as UserCell</span><br><span class="line"></span><br><span class="line">userCell.configureWithUser(user)</span><br></pre></td></tr></table></figure>
<p>一个cell视图直接配置在模型中，因此，违背了苹果MVC的指导，但是一直在发生，并且通常人们不知道这是错误的。如果严格按照MVC模式。你应该从控制器中配置这个cell，并且不能把Model放进View，但这将增长控制器<br>的容量。</p>
<p><strong>Cocoa MVC 是合情合理的未经简略的成为重量级视图控制器.</strong></p>
<p>这个问题可能不是很明显，直到它涉及到单元测试（想想，它在你的项目中）。因为您的视图控制器被紧密耦合的视图，它变得很难测试，因为你必须非常有创意的mocking视图和他们的生命周期，而写的视图控制器的代码，在这样一种方式，您的业务逻辑是尽可能分离从视图布局代码。<br>让我们来看看简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line">struct Person &#123; // Model</span><br><span class="line">   let firstName: String</span><br><span class="line">   let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingViewController : UIViewController &#123; // View + Controller</span><br><span class="line">   var person: Person!</span><br><span class="line">   let showGreetingButton = UIButton()</span><br><span class="line">   let greetingLabel = UILabel()</span><br><span class="line">   </span><br><span class="line">   override func viewDidLoad() &#123;</span><br><span class="line">       super.viewDidLoad()</span><br><span class="line">       self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func didTapButton(button: UIButton) &#123;</span><br><span class="line">       let greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</span><br><span class="line">       self.greetingLabel.text = greeting</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   // layout code goes here</span><br><span class="line">&#125;</span><br><span class="line">// Assembling of MVC</span><br><span class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.person = model;</span><br></pre></td></tr></table></figure>
<p>这段代码看起来不太好测试对吧？我们可以把 greeting 的生成方法放到一个新类 GreetingModel 里面去单独测试。但是我们如果不调用与 View 相关的方法的话 （viewDidLoad, didTapButton），就测试不到 GreetingViewController 里面任何的显示逻辑（虽然在上面这个例子里面，逻辑已经很少了）；而调用的话就可能需要把所有的 View 都加载出来，这对单元测试来说太不利了。</p>
<p>实际上，在模拟器（比如 iPhone 4S）上运行并测试 View 的显示并不能保证在其他设备上（比如 iPad）也能良好运行。所以我建议把「Host Application」从你的单元测试配置项里移除掉，然后在不启动模拟器的情况下去跑你的单元测试</p>
<p><strong>在视图和控制器交互之间不容易进行单元测试</strong></p>
<p>总之，这似乎看起来MVC是一个不好的模式选择。但是让我们阐述就它的特点在上文开始时定义的那些：</p>
<ul>
<li>分配 — 视图与模型实际上是分开的，但是视图与控制器是紧耦合的。</li>
<li>可测性 — 由于分配的不够清楚，所有能测试的仅仅模型而已。</li>
<li>易用性 — 相较于其他模式，它的代码量最小，而且基本每个人都很熟悉它，即便是没有太多经验开发者也能维护。</li>
</ul>
<p>Cocoa MVC 是一个很好的选择模式，如果你不想投入大量的时间在你的架构中，并且你感觉到你高额的维护成本在你的极小工程中。</p>
<p><strong>Cocoa 就开发速度而言，MVC是最好的架构模式</strong></p>
<p>#MVP</p>
<h3 id="保证了职责分配的Cocoa-MVC"><a href="#保证了职责分配的Cocoa-MVC" class="headerlink" title="保证了职责分配的Cocoa MVC"></a>保证了职责分配的Cocoa MVC</h3><p><img src="http://i.imgur.com/aFZ8Kdw.png" alt=""></p>
<p>是不是看起来很像苹果的MVC模式，是的，确实如此，它是MVP。稍等…这个意思是说 Apple 的 MVC 实际上是 MVP 吗？不是的，回想一下，在 MVC 里面 View 和 Controller 是耦合紧密的，但是对于 MVP 里面的 Presenter 来讲，它完全不关注 ViewController 的生命周期，而且 View 也能被简单 mock 出来，所以在 Presenter 里面基本没什么布局相关的代码，它的职责只是通过数据和状态更新 View<br><strong>如果我告诉你 UIViewController 在这里的角色其实是 View.</strong><br>在 MVP 架构里面，UIViewController 的那些子类其实是属于 View 的，而不是 Presenter。这种区别提供了极好的可测性，但是这是用开发速度的代价换来的，因为你必须要手动的去创建数据和绑定事件，像下面这段代码中做的一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">struct Person &#123; // Model</span><br><span class="line">   let firstName: String</span><br><span class="line">   let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: class &#123;</span><br><span class="line">   func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewPresenter &#123;</span><br><span class="line">   init(view: GreetingView, person: Person)</span><br><span class="line">   func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingPresenter : GreetingViewPresenter &#123;</span><br><span class="line">   unowned let view: GreetingView</span><br><span class="line">   let person: Person</span><br><span class="line">   required init(view: GreetingView, person: Person) &#123;</span><br><span class="line">       self.view = view</span><br><span class="line">       self.person = person</span><br><span class="line">   &#125;</span><br><span class="line">   func showGreeting() &#123;</span><br><span class="line">       let greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</span><br><span class="line">       self.view.setGreeting(greeting)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingViewController : UIViewController, GreetingView &#123;</span><br><span class="line">   var presenter: GreetingViewPresenter!</span><br><span class="line">   let showGreetingButton = UIButton()</span><br><span class="line">   let greetingLabel = UILabel()</span><br><span class="line">   </span><br><span class="line">   override func viewDidLoad() &#123;</span><br><span class="line">       super.viewDidLoad()</span><br><span class="line">       self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func didTapButton(button: UIButton) &#123;</span><br><span class="line">       self.presenter.showGreeting()</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   func setGreeting(greeting: String) &#123;</span><br><span class="line">       self.greetingLabel.text = greeting</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // layout code goes here</span><br><span class="line">&#125;</span><br><span class="line">// Assembling of MVP</span><br><span class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter(view: view, person: model)</span><br><span class="line">view.presenter = presenter</span><br></pre></td></tr></table></figure>
<p>就组装而言的重要性说明</p>
<p>MVP架构拥有三个完全地独立的分层，这也在组装的时候产生一些问题，而MVP也成了第一个披露了这种问题的架构。由于我们不想让View知道Model的信息，所以在当前的 ViewController（角色其实是 View）里面去进行组装肯定是不正确的，我们应该在另外的地方完成组装。比如，我们可以创建一个应用层（app-wide）的 Router 服务，让它来负责组装和 View-to-View 的转场。这个问题不仅在 MVP 中存在，在接下来要介绍的模式里面也都有这个问题。<br>让我们了解MVP的特点：</p>
<ul>
<li><p>分配 -  我们把大部分的职责都分配到了 Presenter 和 Model 里面，而 View 基本上不需要做什么（在上面的例子里面，Model 也什么都没做）。</p>
</li>
<li><p>可测性 - 简直棒，我们可以通过 View 来测试大部分的业务逻辑。</p>
</li>
<li><p>易用性 - 就我们上面那个简单的例子来讲，代码量差不多是 MVC 架构的两倍，但是 MVP 的思路还是蛮清晰的。</p>
</li>
</ul>
<p><strong>MVP 架构在 iOS 中意味着极好的可测性和巨大的代码量。</strong></p>
<p>MVP - 数据绑定的另一个版本<br><img src="http://i.imgur.com/2WqqwTs.png" alt=""></p>
<p>还存在着另一种的 MVP - Supervising Controller MVP。这个版本的 MVP 包括了 View 和 Model 的直接绑定，与此同时 Presenter（Supervising Controller）仍然继续处理 View 上的用户操作，控制 View 的显示变化。</p>
<p>但是我们之前讲过，模糊的职责划分是不好的事情，比如 View 和 Model 的紧耦合。这个道理在 Cocoa 桌面应用开发上面也是一样的。</p>
<p>就像传统 MVC 架构一样，我找不到有什么理由需要为这个有瑕疵的架构写一个例子。</p>
<h1 id="MVVM-最流行的，最好的在MV-X-中"><a href="#MVVM-最流行的，最好的在MV-X-中" class="headerlink" title="MVVM - 最流行的，最好的在MV(X)中"></a>MVVM - 最流行的，最好的在MV(X)中</h1><p>MVVM 架构是 MV(X) 里面最新的一个，让我们希望它在出现的时候已经考虑到了 MV(X) 模式之前所遇到的问题吧。</p>
<p>理论上来说，Model - View - ViewModel 看起来非常棒。View 和 Model 我们已经都熟悉了，中间人的角色我们也熟悉了，但是在这里中间人的角色变成了 ViewModel。<br><img src="http://i.imgur.com/WO4LBgV.png" alt=""><br>它跟 MVP 很像：</p>
<p>MVVM 架构把 ViewController 看做 View。<br>View 和 Model 之间没有紧耦合<br>另外，它还像 Supervising 版的 MVP 那样做了数据绑定，不过这次不是绑定 View 和 Model，而是绑定 View 和 ViewModel。</p>
<p>那么，iOS 里面的 ViewModel 到底是个什么东西呢？本质上来讲，他是独立于 UIKit 的， View 和 View 的状态的一个呈现（representation）。ViewModel 能主动调用对 Model 做更改，也能在 Model 更新的时候对自身进行调整，然后通过 View 和 ViewModel 之间的绑定，对 View 也进行对应的更新。</p>
<p>绑定<br>我在 MVP 的部分简单的提过这个内容，在这里让我们再延伸讨论一下。绑定这个概念源于 OS X 平台的开发，但是在 iOS 平台上面，我们并没有对应的开发工具。当然，我们也有 KVO 和 通知，但是用这些方式去做绑定不太方便。</p>
<p>那么，如果我们不想自己去写他们的话，下面提供了两个选择：</p>
<p>选一个基于 KVO 的绑定库，比如 RZDataBinding 或者 SwiftBond。<br>使用全量级的 函数式响应编程 框架,比如 ReactiveCocoa、RxSwift 或者 PromiseKit。<br>实际上，现在提到「MVVM」你应该就会想到 ReactiveCocoa，反过来也是一样。虽然我们可以通过简单的绑定来实现 MVVM 模式，但是 ReactiveCocoa（或者同类型的框架）会让你更大限度的去理解 MVVM。</p>
<p>响应式编程框架也有一点不好的地方，能力越大责任越大嘛。用响应式编程用得不好的话，很容易会把事情搞得一团糟。或者这么说，如果有什么地方出错了，你需要花费更多的时间去调试。看着下面这张调用堆栈图感受一下：</p>
<p>在接下来的这个小例子中，用响应式框架（FRF）或者 KVO 都显得有点大刀小用，所以我们用另一种方式：直接的调用 ViewModel 的 showGreeting 方法去更新自己（的 greeting 属性），（在 greeting 属性的 didSet 回调里面）用 greetingDidChange 闭包函数去更新 View 的显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">struct Person &#123; // Model</span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewModelProtocol: class &#123;</span><br><span class="line">    var greeting: String? &#123; get &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? &#123; get set &#125; // function to call when greeting did change</span><br><span class="line">    init(person: Person)</span><br><span class="line">    func showGreeting()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingViewModel : GreetingViewModelProtocol &#123;</span><br><span class="line">    let person: Person</span><br><span class="line">    var greeting: String? &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            self.greetingDidChange?(self)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?</span><br><span class="line">    required init(person: Person) &#123;</span><br><span class="line">        self.person = person</span><br><span class="line">    &#125;</span><br><span class="line">    func showGreeting() &#123;</span><br><span class="line">        self.greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingViewController : UIViewController &#123;</span><br><span class="line">    var viewModel: GreetingViewModelProtocol! &#123;</span><br><span class="line">        didSet &#123;</span><br><span class="line">            self.viewModel.greetingDidChange = &#123; [unowned self] viewModel in</span><br><span class="line">                self.greetingLabel.text = viewModel.greeting</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let showGreetingButton = UIButton()</span><br><span class="line">    let greetingLabel = UILabel()</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        self.showGreetingButton.addTarget(self.viewModel, action: &quot;showGreeting&quot;, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line">    // layout code goes here</span><br><span class="line">&#125;</span><br><span class="line">// Assembling of MVVM</span><br><span class="line">let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)</span><br><span class="line">let viewModel = GreetingViewModel(person: model)</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">view.viewModel = viewModel</span><br></pre></td></tr></table></figure>
<p>然后，我们再回过头来对它各方面的表现做一个评价：</p>
<ul>
<li><p>划分 - 这在我们的小栗子里面表现的不是很清楚，但是 MVVM 框架里面的 View 比 MVP 里面负责的事情要更多一些。因为前者是通过 ViewModel 的数据绑定来更新自身状态的，而后者只是把所有的事件统统交给 Presenter 去处理就完了，自己本身并不负责更新。</p>
</li>
<li><p>可测性 - 因为 ViewModel 对 View 是一无所知的，这样我们对它的测试就变得很简单。View 应该也是能够被测试的，但是可能因为它对 UIKit 的依赖，你会直接略过它。</p>
</li>
<li><p>易用 - 在我们的例子里面，它的代码量基本跟 MVP 持平，但是在实际的应用当中 MVVM 会更简洁一些。因为在 MVP 下你必须要把 View 的所有事件都交给 Presenter 去处理，而且需要手动的去更新 View 的状态；而在 MVVM 下，你只需要用绑定就可以解决。<br>MVVM 真的很有魅力，因为它不仅结合了上述几种框架的优点，还不需要你为视图的更新去写额外的代码（因为在 View 上已经做了数据绑定），另外它在可测性上的表现也依然很棒。</p>
</li>
</ul>
<h1 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h1><p><img src="http://i.imgur.com/D4N9MeU.png" alt=""></p>
<p>VIPER 是我们最后一个要介绍的框架，这个框架比较有趣的是它不属于任何一种 MV(X) 框架。</p>
<p>到目前为止，你可能觉得我们把职责划分成三层，这个颗粒度已经很不错了吧。现在 VIPER 从另一个角度对职责进行了划分，这次划分了 五层。</p>
<p>Interactor（交互器） - 包括数据（Entities）或者网络相关的业务逻辑。比如创建新的 entities 或者从服务器上获取数据；要实现这些功能，你可能会用到一些服务和管理（Services and Managers）：这些可能会被误以为成是外部依赖东西，但是它们就是 VIPER 的 Interactor 模块。<br>Presenter（展示器） - 包括 UI（but UIKit independent）相关的业务逻辑，可以调用 Interactor 中的方法。<br>Entities（实体） - 纯粹的数据对象。不包括数据访问层，因为这是 Interactor 的职责。<br>Router（路由） - 负责 VIPER 模块之间的转场<br>实际上 VIPER 模块可以只是一个页面（screen），也可以是你应用里整个的用户使用流程（the whole user story）- 比如说「验证」这个功能，它可以只是一个页面，也可以是连续相关的一组页面。你的每个「乐高积木」想要有多大，都是你自己来决定的。</p>
<p>如果我们把 VIPER 和 MV(X) 系列做一个对比的话，我们会发现它们在职责划分上面有下面的一些区别：</p>
<ul>
<li>Model（数据交互）的逻辑被转移到了 Interactor 里面，Entities 只是一个什么都不用做的数据结构体。</li>
<li>Controller/Presenter/ViewModel 的职责里面，只有 UI 的展示功能被转移到了 <em> </em> * Presenter 里面。Presenter 不具备直接更改数据的能力。</li>
<li>VIPER 是第一个把导航的职责单独划分出来的架构模式，负责导航的就是 Router 层。<br>如何正确的使用导航（doing routing）对于 iOS 应用开发来说是一个挑战，MV(X) 系列的架构完全就没有意识到（所以也不用处理）这个问题。</li>
</ul>
<p>下面的这个列子并没有涉及到导航和 VIPER 模块间的转场，同样上面 MV(X) 系列架构里面也都没有涉及。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">struct Person &#123; // Entity (usually more complex e.g. NSManagedObject)</span><br><span class="line">    let firstName: String</span><br><span class="line">    let lastName: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct GreetingData &#123; // Transport data structure (not Entity)</span><br><span class="line">    let greeting: String</span><br><span class="line">    let subject: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingProvider &#123;</span><br><span class="line">    func provideGreetingData()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingOutput: class &#123;</span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingInteractor : GreetingProvider &#123;</span><br><span class="line">    weak var output: GreetingOutput!</span><br><span class="line"></span><br><span class="line">    func provideGreetingData() &#123;</span><br><span class="line">        let person = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;) // usually comes from data access layer</span><br><span class="line">        let subject = person.firstName + &quot; &quot; + person.lastName</span><br><span class="line">        let greeting = GreetingData(greeting: &quot;Hello&quot;, subject: subject)</span><br><span class="line">        self.output.receiveGreetingData(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingViewEventHandler &#123;</span><br><span class="line">    func didTapShowGreetingButton()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protocol GreetingView: class &#123;</span><br><span class="line">    func setGreeting(greeting: String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingPresenter : GreetingOutput, GreetingViewEventHandler &#123;</span><br><span class="line">    weak var view: GreetingView!</span><br><span class="line">    var greetingProvider: GreetingProvider!</span><br><span class="line"></span><br><span class="line">    func didTapShowGreetingButton() &#123;</span><br><span class="line">        self.greetingProvider.provideGreetingData()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func receiveGreetingData(greetingData: GreetingData) &#123;</span><br><span class="line">        let greeting = greetingData.greeting + &quot; &quot; + greetingData.subject</span><br><span class="line">        self.view.setGreeting(greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GreetingViewController : UIViewController, GreetingView &#123;</span><br><span class="line">    var eventHandler: GreetingViewEventHandler!</span><br><span class="line">    let showGreetingButton = UIButton()</span><br><span class="line">    let greetingLabel = UILabel()</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func didTapButton(button: UIButton) &#123;</span><br><span class="line">        self.eventHandler.didTapShowGreetingButton()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func setGreeting(greeting: String) &#123;</span><br><span class="line">        self.greetingLabel.text = greeting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // layout code goes here</span><br><span class="line">&#125;</span><br><span class="line">// Assembling of VIPER module, without Router</span><br><span class="line">let view = GreetingViewController()</span><br><span class="line">let presenter = GreetingPresenter()</span><br><span class="line">let interactor = GreetingInteractor()</span><br><span class="line">view.eventHandler = presenter</span><br><span class="line">presenter.view = view</span><br><span class="line">presenter.greetingProvider = interactor</span><br><span class="line">interactor.output = presente</span><br></pre></td></tr></table></figure>
<p>我们再来评价下它在各方面的表现：</p>
<ul>
<li>划分 - 毫无疑问的，VIPER 在职责划分方面是做的最好的。</li>
<li>可测性 - 理所当然的，职责划分的越好，测试起来就越容易</li>
<li>易用 - 最后，你可能已经猜到了，上面两点好处都是用维护性的代价换来的。一个小小的任务，可能就需要你为各种类写大量的接口。</li>
</ul>
<p>那么，我们到底应该给「乐高」一个怎样的评价呢？</p>
<p>如果你在使用 VIPER 框架的时候有一种在用乐高积木搭建帝国大厦的感觉，那么你可能 正在犯错误；可能对于你负责的应用来说，还没有到使用 VIPER 的时候，你应该把一些事情考虑的再简单一些。总是有一些人忽视这个问题，继续扛着大炮去打小鸟。我觉得可能是因为他们相信，虽然目前来看维护成本高的不合常理，但是至少在将来他们的应用可以从 VIPER 架构上得到回报吧。如果你也跟他们的观点一样的话，那我建议你尝试一下 Generamba - 一个可以生成 VIPER 框架的工具。虽然对于我个人来讲，这感觉就像给大炮装上了一个自动瞄准系统，然后去做一件只用弹弓就能解决的事情。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们简单了解了几种架构模式，对于那些让你困惑的问题，我希望你已经找到了答案。但是毫无疑问，你应该已经意识到了，在选择架构模式这件问题上面，不存在什么 银色子弹，你需要做的就是具体情况具体分析，权衡利弊而已。</p>
<p>因此在同一个应用里面，即便有几种混合的架构模式也是很正常的一件事情。比如：开始的时候，你用的是 MVC 架构，后来你意识到有一个特殊的页面用 MVC 做的的话维护起来会相当的麻烦；这个时候你可以只针对这一个页面用 MVVM 模式去开发，对于之前那些用 MVC 就能正常工作的页面，你完全没有必要去重构它们，因为两种架构是完全可以和睦共存的。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.oy3ca9ckf" title="ios架构模式- 英文原文" target="_blank" rel="noopener">ios架构模式- 英文原文版 - 翻墙</a></li>
<li><a href="https://blog.coding.net/blog/ios-architecture-patterns" target="_blank" rel="noopener">ios架构模式- 中文译文版</a></li>
<li><a href="http://www.teehanlax.com/blog/model-view-viewmodel-for-ios/" target="_blank" rel="noopener">Model-View-ViewModel for iOS - 英文版 - 翻墙</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/21/architecture/" data-id="cjrja9bsm000ewy2h4jfa7ntu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-regex-4" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/13/regex-4/" class="article-date">
  <time datetime="2016-03-13T05:24:17.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/regex-4/">学习正则表达式 （五）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/13/regex-4/" data-id="cjrja9bs30009wy2h78bvlv23" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-regex-3" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/13/regex-3/" class="article-date">
  <time datetime="2016-03-13T05:24:11.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/regex-3/">学习正则表达式 （四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/13/regex-3/" data-id="cjrja9bs20008wy2hlesywibx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-regex-2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/13/regex-2/" class="article-date">
  <time datetime="2016-03-13T05:23:56.000Z" itemprop="datePublished">2016-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/13/regex-2/">学习正则表达式 （三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-边界"><a href="#第三章-边界" class="headerlink" title="第三章 边界"></a>第三章 边界</h1><p>本章的重点是断言，用来标记边界，但不消耗字符。也就是说，字符并不会返回到结果中。断言也被称作零宽度断言。零宽度断言不匹配字符，而是匹配字符串中的位置。<br>本章主要学习几种：</p>
<ul>
<li>行或字符串的起始与结束位置；</li>
<li>单词边界；</li>
<li>主题词的起始与结束位置；</li>
<li>引用字符串字面值的边界；</li>
</ul>
<p>我们使用另一个工具<a href="http://gskinner.com/regexr" title="RegExr" target="_blank" rel="noopener">RegExr</a>。</p>
<h2 id="3-1-行的起始与结束"><a href="#3-1-行的起始与结束" class="headerlink" title="3.1 行的起始与结束"></a>3.1 行的起始与结束</h2><h2 id="3-2-单词边界与非单词边界"><a href="#3-2-单词边界与非单词边界" class="headerlink" title="3.2 单词边界与非单词边界"></a>3.2 单词边界与非单词边界</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>微信公众号：嘀咕嘀咕（iOSSharers）</p>
<p>扫二维码关注</p>
<p><img src="http://i.imgur.com/TUz7oc9.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/03/13/regex-2/" data-id="cjrja9bs10007wy2hkif6wutv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/05/24/设计模式之命令模式/">设计模式之命令模式</a>
          </li>
        
          <li>
            <a href="/2016/05/23/code-style/">良好代码风格是一种艺术 -- Objective-C</a>
          </li>
        
          <li>
            <a href="/2016/05/22/Bool/">BOOL，你真的了解吗？</a>
          </li>
        
          <li>
            <a href="/2016/03/23/strategy/">设计模式之策略模式</a>
          </li>
        
          <li>
            <a href="/2016/03/23/isa/">Object-C的继承isa指针</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>